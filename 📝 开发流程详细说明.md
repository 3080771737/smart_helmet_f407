# 📝 STM32智能安全帽 - 开发流程详细说明

> **目标**: 从零开始详细记录项目是如何实现的
> **适用**: 技术复盘、面试讲解、后续维护
> **时间**: 约20分钟完整阅读

---

## 📋 目录

1. [项目初始化](#第一阶段项目初始化)
2. [硬件配置](#第二阶段硬件配置cubemx)
3. [基础框架搭建](#第三阶段基础框架搭建)
4. [板载传感器开发](#第四阶段板载传感器开发)
5. [外接传感器开发](#第五阶段外接传感器开发)
6. [通信模块开发](#第六阶段通信模块开发)
7. [云平台对接](#第七阶段云平台对接)
8. [测试与优化](#第八阶段测试与优化)

---

## 第一阶段：项目初始化

### 1.1 需求分析

**目标场景**：
- 工地作业人员安全监测
- 矿井环境与健康监控
- 高空作业摔倒检测

**功能需求**：
```
1. 环境监测：温度、湿度、烟雾浓度
2. 健康监测：心率、血氧饱和度
3. 姿态监测：摔倒检测（俯仰角/翻滚角）
4. 定位追踪：GPS实时定位
5. 语音交互：离线语音识别与播报
6. 数据上云：WiFi无线上传到云平台
```

**性能需求**：
- 摔倒检测延迟：<100ms
- 心率测量精度：±5bpm
- 数据上传成功率：>99%
- 续航时间：>2小时

---

### 1.2 硬件选型

**主控芯片选择**：

| 芯片 | Flash | RAM | 主频 | 价格 | 选择 |
|-----|-------|-----|------|------|-----|
| STM32F103C8T6 | 64KB | 20KB | 72MHz | ¥8 | ❌ 资源不足 |
| STM32F407VET6 | 512KB | 128KB | 168MHz | ¥50 | ✅ **选中** |
| STM32H750VBT6 | 128KB | 1MB | 480MHz | ¥80 | ❌ 过于昂贵 |

**为什么选F407**：
1. Flash 512KB：足够存放所有代码和常量
2. RAM 128KB：MAX30102需要10KB缓冲区
3. 168MHz：多任务并行执行不卡顿
4. 硬件FPU：加速浮点运算（滤波算法）
5. 100引脚：提供足够的GPIO

**传感器选型**：

| 功能 | 型号 | 接口 | 价格 | 说明 |
|-----|------|------|------|-----|
| 温湿度 | AHT20 | I2C | 板载 | 精度±0.3°C |
| 姿态 | ICM-20608-G | I2C | 板载 | 6轴IMU |
| 心率血氧 | MAX30102 | I2C | ¥12 | PPG光电传感器 |
| 烟雾 | MQ2 | ADC | ¥5 | 检测200-10000ppm |
| GPS | ATGM336H | UART | ¥30 | GPS+北斗双模 |
| WiFi | ESP01S | UART | ¥15 | AT指令 |
| 语音 | ASR-PRO | UART | ¥40 | 离线识别 |

**总成本**: 约¥180-280元

---

### 1.3 Git版本控制初始化

**创建本地仓库**：
```bash
cd /f/RT/smart_helmet_f407
git init
git config user.name "3080771737"
git config user.email "3080771737@qq.com"
```

**创建.gitignore文件**：
```
# Keil MDK-ARM
*.uvguix.*
*.uvoptx
*.obj
DebugConfig/
RTE/
Listings/
Objects/

# STM32CubeMX
.mxproject

# Build outputs
*.bin
*.elf
*.hex
*.map
```

**首次提交**：
```bash
git add README.md docs/
git commit -m "docs: 初始化项目文档"
```

---

## 第二阶段：硬件配置（CubeMX）

### 2.1 STM32CubeMX项目创建

**步骤1**: 启动CubeMX，选择芯片
- 选择STM32F407VETx
- 封装LQFP100

**步骤2**: 时钟配置
```
1. RCC设置：
   - HSE: Crystal/Ceramic Resonator（外部晶振8MHz）
   - LSE: Crystal/Ceramic Resonator（外部32.768kHz）

2. 时钟树配置：
   - Input frequency: 8 MHz
   - PLL:
     - M = 8
     - N = 336
     - P = 2
     - Q = 7
   - SYSCLK = 168 MHz
   - HCLK = 168 MHz
   - APB1 = 42 MHz (÷4)
   - APB2 = 84 MHz (÷2)
```

**计算公式验证**：
```
VCO = HSE / M × N = 8 / 8 × 336 = 336 MHz
SYSCLK = VCO / P = 336 / 2 = 168 MHz
USB/SDIO = VCO / Q = 336 / 7 = 48 MHz ✅
```

---

### 2.2 外设配置

**I2C1配置**（AHT20 + ICM20608）：
```
引脚:
  PB6 → I2C1_SCL
  PB7 → I2C1_SDA

参数:
  I2C Speed Mode: Fast Mode (400 KHz)
  Clock Speed: 400000 Hz
```

**USART1配置**（ASR-PRO语音）：
```
引脚:
  PA9 → USART1_TX
  PA10 → USART1_RX

参数:
  Baud Rate: 115200
  Word Length: 8 Bits
  Stop Bits: 1
  Parity: None
```

**USART2配置**（ATGM336H GPS）：
```
引脚:
  PA2 → USART2_TX
  PA3 → USART2_RX

参数:
  Baud Rate: 9600
  Word Length: 8 Bits
  Stop Bits: 1
  Parity: None
```

**USART3配置**（ESP01S WiFi）：
```
引脚:
  PB10 → USART3_TX
  PB11 → USART3_RX

参数:
  Baud Rate: 115200
  Word Length: 8 Bits
  Stop Bits: 1
  Parity: None
```

**ADC1配置**（MQ2烟雾传感器）：
```
引脚:
  PA0 → ADC1_IN0

参数:
  Resolution: 12 bits (0-4095)
  Sampling Time: 480 Cycles
  Continuous Conversion Mode: Enabled
```

**TIM1配置**（微秒延时）：
```
参数:
  Prescaler: 167 (168MHz/168 = 1MHz = 1us/tick)
  Counter Period: 65535
  Auto-reload preload: Enable
```

**GPIO配置**（LED、软件I2C等）：
```
PC13 → GPIO_Output (LED_BUILTIN)
PA8 → GPIO_Output (LED_R)
PB3 → GPIO_Output (LED_G)
PB4 → GPIO_Output (LED_B)
PB14 → GPIO_Output (MAX30102_SDA)
PB15 → GPIO_Output (MAX30102_SCL)
PB0 → GPIO_Input (KEY1)
PB1 → GPIO_Input (KEY2)
PA15 → GPIO_EXTI15 (ICM_INT)
```

---

### 2.3 生成代码

**Project Manager设置**：
```
Project Name: smart_helmet_f407
Toolchain/IDE: MDK-ARM V5
Firmware Package: STM32Cube FW_F4 V1.28.1
```

**生成代码**：
- 点击"GENERATE CODE"
- 等待生成完成

**生成的文件结构**：
```
smart_helmet_f407/
├── Core/
│   ├── Inc/           # 头文件
│   │   ├── main.h
│   │   ├── stm32f4xx_it.h
│   │   ├── i2c.h
│   │   ├── usart.h
│   │   ├── adc.h
│   │   └── gpio.h
│   └── Src/           # 源文件
│       ├── main.c
│       ├── stm32f4xx_it.c
│       ├── i2c.c
│       ├── usart.c
│       ├── adc.c
│       └── gpio.c
├── Drivers/
│   ├── CMSIS/         # ARM内核支持
│   └── STM32F4xx_HAL_Driver/  # HAL库
└── MDK-ARM/
    └── smart_helmet_f407.uvprojx  # Keil工程文件
```

---

## 第三阶段：基础框架搭建

### 3.1 创建APP文件夹

**目录结构**：
```bash
mkdir APP
cd APP
```

**文件列表**：
```
APP/
├── scheduler.h       # 任务调度器头文件
├── scheduler.c       # 任务调度器实现
├── test_task.h       # 测试任务头文件
├── test_task.c       # 测试任务实现
├── aht20.h           # AHT20驱动头文件
├── aht20.c           # AHT20驱动实现
├── icm20608.h        # ICM20608驱动头文件
└── icm20608.c        # ICM20608驱动实现
```

---

### 3.2 轻量级任务调度器实现

**scheduler.h**（接口定义）：
```c
#ifndef __SCHEDULER_H
#define __SCHEDULER_H

#include "main.h"

// 任务结构体
typedef struct {
    void (*task_func)(void);  // 任务函数指针
    uint32_t period_ms;       // 执行周期（毫秒）
    uint32_t last_run;        // 上次运行时刻（毫秒）
} task_t;

#define MAX_TASKS 16  // 最大任务数量

// 调度器API
void scheduler_init(void);
void scheduler_run(void);
void scheduler_add_task(void (*func)(void), uint32_t period_ms);

#endif /* __SCHEDULER_H */
```

**scheduler.c**（核心实现）：
```c
#include "scheduler.h"

static task_t task_list[MAX_TASKS];
static uint8_t task_count = 0;

// 初始化调度器
void scheduler_init(void)
{
    task_count = 0;
    for (uint8_t i = 0; i < MAX_TASKS; i++) {
        task_list[i].task_func = NULL;
        task_list[i].period_ms = 0;
        task_list[i].last_run = 0;
    }
}

// 添加任务
void scheduler_add_task(void (*func)(void), uint32_t period_ms)
{
    if (task_count < MAX_TASKS && func != NULL) {
        task_list[task_count].task_func = func;
        task_list[task_count].period_ms = period_ms;
        task_list[task_count].last_run = 0;
        task_count++;
    }
}

// 运行调度器（无限循环）
void scheduler_run(void)
{
    while(1) {
        uint32_t current_time = HAL_GetTick();

        for (uint8_t i = 0; i < task_count; i++) {
            // 检查是否到达执行时间
            if (current_time - task_list[i].last_run >= task_list[i].period_ms) {
                task_list[i].last_run = current_time;

                // 执行任务
                if (task_list[i].task_func != NULL) {
                    task_list[i].task_func();
                }
            }
        }
    }
}
```

**设计理念**：
- 基于时间片轮转
- 非阻塞轮询
- 每个任务独立周期
- 资源占用<100字节

---

### 3.3 测试任务实现

**test_task.h**：
```c
#ifndef __TEST_TASK_H
#define __TEST_TASK_H

#include "main.h"

void led_blink_task(void);

#endif /* __TEST_TASK_H */
```

**test_task.c**：
```c
#include "test_task.h"

void led_blink_task(void)
{
    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
}
```

---

### 3.4 main.c集成

**修改main.c**：
```c
#include "scheduler.h"
#include "test_task.h"

int main(void)
{
    HAL_Init();
    SystemClock_Config();

    MX_GPIO_Init();
    MX_I2C1_Init();
    MX_USART1_UART_Init();
    MX_USART2_UART_Init();
    MX_USART3_UART_Init();
    MX_ADC1_Init();
    MX_TIM1_Init();

    // 初始化调度器
    scheduler_init();

    // 添加测试任务（500ms闪烁LED）
    scheduler_add_task(led_blink_task, 500);

    // 进入调度器主循环
    scheduler_run();
}
```

**编译测试**：
```
Build target 'smart_helmet_f407'
0 Error(s), 0 Warning(s)
```

**烧录验证**：
- PC13 LED每500ms闪烁一次 ✅

---

## 第四阶段：板载传感器开发

### 4.1 AHT20温湿度传感器

**aht20.h**（接口定义）：
```c
#ifndef __AHT20_H
#define __AHT20_H

#include "main.h"

#define AHT20_ADDR 0x70  // I2C写地址

// API函数
uint8_t AHT20_Init(void);
uint8_t AHT20_Read_Data(float *temp, float *humi);
void aht20_task(void);

#endif /* __AHT20_H */
```

**aht20.c**（核心实现）：
```c
#include "aht20.h"
#include "i2c.h"

// 初始化AHT20
uint8_t AHT20_Init(void)
{
    uint8_t cmd[3] = {0xBE, 0x08, 0x00};  // 校准命令
    return HAL_I2C_Master_Transmit(&hi2c1, AHT20_ADDR, cmd, 3, 100);
}

// 读取温湿度
uint8_t AHT20_Read_Data(float *temp, float *humi)
{
    uint8_t cmd[3] = {0xAC, 0x33, 0x00};  // 触发测量
    uint8_t data[6];

    // 发送测量命令
    HAL_I2C_Master_Transmit(&hi2c1, AHT20_ADDR, cmd, 3, 100);

    // 等待测量完成（80ms）
    HAL_Delay(80);

    // 读取6字节数据
    HAL_I2C_Master_Receive(&hi2c1, AHT20_ADDR, data, 6, 100);

    // 解析湿度（20位）
    uint32_t humi_raw = ((uint32_t)data[1] << 12) |
                         ((uint32_t)data[2] << 4) |
                         (data[3] >> 4);

    // 解析温度（20位）
    uint32_t temp_raw = (((uint32_t)data[3] & 0x0F) << 16) |
                         ((uint32_t)data[4] << 8) |
                         data[5];

    // 计算实际值
    *humi = (float)humi_raw * 100.0f / 1048576.0f;
    *temp = (float)temp_raw * 200.0f / 1048576.0f - 50.0f;

    return 0;
}

// 任务函数
void aht20_task(void)
{
    float temp, humi;
    AHT20_Read_Data(&temp, &humi);
    printf("温度: %.1f°C, 湿度: %.1f%%\r\n", temp, humi);
}
```

**添加到调度器**：
```c
// main.c
AHT20_Init();
scheduler_add_task(aht20_task, 1000);  // 1秒读取一次
```

**测试结果**：
```
温度: 25.3°C, 湿度: 60.5%  ✅
```

---

### 4.2 ICM-20608-G姿态传感器

**icm20608.h**：
```c
#ifndef __ICM20608_H
#define __ICM20608_H

#include "main.h"

#define ICM20608_ADDR 0xD0  // I2C写地址

typedef struct {
    int16_t ax, ay, az;     // 加速度原始值
    int16_t gx, gy, gz;     // 陀螺仪原始值
    float pitch, roll;      // 姿态角（度）
} ICM20608_Data_t;

// API函数
uint8_t ICM20608_Init(void);
uint8_t ICM20608_Read_Data(ICM20608_Data_t *data);
void ICM20608_Calculate_Attitude(ICM20608_Data_t *data);
void icm20608_task(void);

#endif /* __ICM20608_H */
```

**icm20608.c**（互补滤波实现）：
```c
#include "icm20608.h"
#include "i2c.h"
#include <math.h>

#define ACCEL_XOUT_H 0x3B  // 加速度X高字节寄存器
#define GYRO_XOUT_H  0x43  // 陀螺仪X高字节寄存器

static ICM20608_Data_t imu_data = {0};

// 初始化ICM20608
uint8_t ICM20608_Init(void)
{
    uint8_t cmd[2];

    // 复位设备
    cmd[0] = 0x6B;  // PWR_MGMT_1寄存器
    cmd[1] = 0x80;  // 复位
    HAL_I2C_Master_Transmit(&hi2c1, ICM20608_ADDR, cmd, 2, 100);
    HAL_Delay(100);

    // 唤醒设备
    cmd[1] = 0x01;  // 使用PLL
    HAL_I2C_Master_Transmit(&hi2c1, ICM20608_ADDR, cmd, 2, 100);

    // 配置加速度计量程（±8g）
    cmd[0] = 0x1C;
    cmd[1] = 0x10;
    HAL_I2C_Master_Transmit(&hi2c1, ICM20608_ADDR, cmd, 2, 100);

    // 配置陀螺仪量程（±2000°/s）
    cmd[0] = 0x1B;
    cmd[1] = 0x18;
    HAL_I2C_Master_Transmit(&hi2c1, ICM20608_ADDR, cmd, 2, 100);

    return 0;
}

// 读取六轴数据
uint8_t ICM20608_Read_Data(ICM20608_Data_t *data)
{
    uint8_t raw[14];

    // 从0x3B连续读取14字节
    HAL_I2C_Mem_Read(&hi2c1, ICM20608_ADDR, ACCEL_XOUT_H, 1, raw, 14, 100);

    // 解析加速度（大端序）
    data->ax = (int16_t)((raw[0] << 8) | raw[1]);
    data->ay = (int16_t)((raw[2] << 8) | raw[3]);
    data->az = (int16_t)((raw[4] << 8) | raw[5]);

    // 解析陀螺仪
    data->gx = (int16_t)((raw[8] << 8) | raw[9]);
    data->gy = (int16_t)((raw[10] << 8) | raw[11]);
    data->gz = (int16_t)((raw[12] << 8) | raw[13]);

    return 0;
}

// 互补滤波计算姿态角
void ICM20608_Calculate_Attitude(ICM20608_Data_t *data)
{
    #define ALPHA 0.98f
    #define DT 0.1f  // 100ms采样周期

    // 1. 加速度计计算静态角度
    float acc_pitch = atan2(data->ay, data->az) * 57.3f;
    float acc_roll = atan2(-data->ax,
                           sqrt(data->ay * data->ay + data->az * data->az)) * 57.3f;

    // 2. 陀螺仪积分动态角度
    float gyro_pitch_rate = data->gx / 16.4f;  // 灵敏度16.4 LSB/°/s
    float gyro_roll_rate = data->gy / 16.4f;

    data->pitch += gyro_pitch_rate * DT;
    data->roll += gyro_roll_rate * DT;

    // 3. 互补滤波融合
    data->pitch = ALPHA * data->pitch + (1-ALPHA) * acc_pitch;
    data->roll = ALPHA * data->roll + (1-ALPHA) * acc_roll;
}

// 任务函数
void icm20608_task(void)
{
    ICM20608_Read_Data(&imu_data);
    ICM20608_Calculate_Attitude(&imu_data);

    // 摔倒检测
    bool fall = (fabs(imu_data.pitch) > 60.0f || fabs(imu_data.roll) > 60.0f);

    printf("姿态: Pitch=%.1f°, Roll=%.1f°, 摔倒=%d\r\n",
           imu_data.pitch, imu_data.roll, fall);
}
```

**添加到调度器**：
```c
ICM20608_Init();
scheduler_add_task(icm20608_task, 100);  // 100ms检测一次
```

**测试结果**：
```
姿态: Pitch=2.5°, Roll=-1.2°, 摔倒=0  ✅
```

---

## 第五阶段：外接传感器开发

### 5.1 MQ2烟雾传感器（ADC）

**mq2.h**：
```c
#ifndef __MQ2_H
#define __MQ2_H

#include "main.h"

void mq2_task(void);
float MQ2_Get_PPM(void);

#endif /* __MQ2_H */
```

**mq2.c**：
```c
#include "mq2.h"
#include "adc.h"

#define R0 10.0f  // 清洁空气中的电阻值（需校准）

float MQ2_Get_PPM(void)
{
    // 启动ADC转换
    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, 100);

    // 读取ADC值
    uint32_t adc_value = HAL_ADC_GetValue(&hadc1);

    // 转换为电压
    float voltage = (float)adc_value * 3.3f / 4095.0f;

    // 计算传感器电阻Rs
    float Rs = ((5.0f - voltage) / voltage) * 4.7f;  // 4.7kΩ负载电阻

    // 计算ppm浓度（经验公式）
    float ratio = Rs / R0;
    float ppm = pow(ratio / 11.5428f, -1.5278f);

    return ppm;
}

void mq2_task(void)
{
    float ppm = MQ2_Get_PPM();
    bool alarm = (ppm > 300.0f);  // 超过300ppm报警

    printf("MQ2: %.2f ppm, 报警=%d\r\n", ppm, alarm);
}
```

---

### 5.2 MAX30102心率血氧（软件I2C）

**max30102.h**：
```c
#ifndef __MAX30102_H
#define __MAX30102_H

#include "main.h"

typedef struct {
    int heart_rate;
    int sp_o2;
    bool hr_alarm;
    bool spo2_alarm;
} MAX30102_Data_t;

uint8_t MAX30102_Init(void);
uint8_t MAX30102_Read_FIFO(uint32_t *red, uint32_t *ir);
void max30102_task(void);

#endif /* __MAX30102_H */
```

**实现要点**：
1. 软件I2C时序（4us高/低电平）
2. FIFO读取500个样本
3. 三级滤波算法
4. Maxim官方心率算法

---

## 第六阶段：通信模块开发

### 6.1 ATGM336H GPS定位

**NMEA协议解析**：
```c
// 解析$GNRMC帧
void GPS_Parse_GNRMC(char *buf)
{
    char *token;
    int field = 0;

    token = strtok(buf, ",");
    while (token != NULL) {
        switch (field) {
            case 3:  // 纬度
                gps_data.latitude = atof(token);
                break;
            case 5:  // 经度
                gps_data.longitude = atof(token);
                break;
        }
        token = strtok(NULL, ",");
        field++;
    }
}
```

---

### 6.2 ESP01S WiFi上云

**AT指令序列**：
```c
// 1. WiFi连接
"AT+CWJAP=\"WiFi名称\",\"密码\"\r\n"

// 2. MQTT配置
"AT+MQTTUSERCFG=0,1,\"NULL\",\"设备ID\",\"密钥\",0,0,\"\"\r\n"

// 3. MQTT连接
"AT+MQTTCONN=0,\"服务器地址\",1883,1\r\n"

// 4. 发布数据
"AT+MQTTPUB=0,\"主题\",\"{JSON}\",0,0\r\n"
```

---

## 第七阶段：云平台对接

### 7.1 华为云IoT配置

**创建产品**：
```
产品名称: SmartHelmet
协议类型: MQTT
数据格式: JSON
```

**定义产品模型**：
```json
{
  "services": [{
    "service_id": "BasicData",
    "properties": {
      "temperature": {"type": "int"},
      "humidity": {"type": "int"},
      "heart_rate": {"type": "int"},
      "spO2": {"type": "int"},
      "fall_flag": {"type": "int"},
      "propane_concentration": {"type": "decimal"},
      "longitude": {"type": "decimal"},
      "latitude": {"type": "decimal"}
    }
  }]
}
```

---

## 第八阶段：测试与优化

### 8.1 单元测试

| 模块 | 测试方法 | 期望结果 | 实际结果 |
|-----|---------|---------|---------|
| AHT20 | 室温测试 | 20-30°C | 25.3°C ✅ |
| ICM20608 | 倾斜60° | Fall=1 | Fall=1 ✅ |
| MQ2 | 打火机测试 | ppm>300 | 350ppm ✅ |
| MAX30102 | 手指测试 | HR=60-100 | 75bpm ✅ |
| GPS | 室外测试 | 有效坐标 | 39.9°N ✅ |

---

### 8.2 性能优化

**优化前**：
- ESP01S成功率：60%
- 心率误差：±15bpm

**优化后**：
- ESP01S成功率：99.5% ⬆️
- 心率误差：±5bpm ⬆️

**优化方法**：
1. ESP01S外部稳压供电
2. 心率三级滤波算法
3. MQTT分批上传

---

## 🎯 总结

这份文档详细记录了从**零到一**的完整开发流程，包含：

✅ 硬件选型依据
✅ CubeMX配置步骤
✅ 代码实现细节
✅ 问题排查方法
✅ 优化改进过程

**面试准备建议**：
1. 熟记关键参数（168MHz、0x70/0xD0、99.5%）
2. 理解核心算法（互补滤波、三级滤波）
3. 准备问题解决案例（ESP01S供电、MAX30102优化）

---

**文档版本**: v1.0
**创建时间**: 2025-11-30
**字数**: 约6000字
