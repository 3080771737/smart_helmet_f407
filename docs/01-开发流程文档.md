# STM32æ™ºèƒ½å®‰å…¨å¸½ - å®Œæ•´å¼€å‘æµç¨‹æ–‡æ¡£

> **ä½œè€…**: åŸºäºSTM32F407VET6çš„æ™ºèƒ½å®‰å…¨å¸½ç³»ç»Ÿ
> **ç›®æ ‡**: å¸®åŠ©ä½ ä»é›¶åˆ°ä¸€å®Œæ•´å¤åˆ»æœ¬é¡¹ç›®ï¼Œå¹¶èƒ½å‘é¢è¯•å®˜æ¸…æ™°è®²è§£å®ç°ç»†èŠ‚
> **æ—¶é—´**: é¢„è®¡2-3å‘¨å®Œæˆ

---

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

### é¡¹ç›®åç§°
STM32F407æ™ºèƒ½å®‰å…¨å¸½ç›‘æµ‹ç³»ç»Ÿï¼ˆå·¥ä¸šçº§å‡çº§ç‰ˆï¼‰

### æ ¸å¿ƒåŠŸèƒ½æ¨¡å—
1. **ç¯å¢ƒç›‘æµ‹**: AHT20æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨ã€MQ2çƒŸé›¾æµ“åº¦æ£€æµ‹
2. **å§¿æ€æ£€æµ‹**: ICM-20608-Gå…­è½´ä¼ æ„Ÿå™¨ï¼ˆæ›¿ä»£MPU6050ï¼‰
3. **å¥åº·ç›‘æµ‹**: MAX30102å¿ƒç‡è¡€æ°§ä¼ æ„Ÿå™¨
4. **å®šä½è¿½è¸ª**: ATGM336H GPSæ¨¡å—
5. **è¯­éŸ³äº¤äº’**: å¤©é—®ASR-PROç¦»çº¿è¯­éŸ³æ§åˆ¶
6. **æ•°æ®ä¸Šäº‘**: ESP01S WiFi + åä¸ºäº‘IoTå¹³å°

### æŠ€æœ¯äº®ç‚¹
- **ç¡¬ä»¶å¹³å°**: STM32F407VET6ï¼ˆ168MHzä¸»é¢‘ï¼Œ512KB Flashï¼‰
- **ä»»åŠ¡è°ƒåº¦**: è½»é‡çº§æ—¶é—´ç‰‡è½®è½¬è°ƒåº¦å™¨ï¼ˆæ— éœ€RTOSï¼‰
- **å¤šçº§æ»¤æ³¢**: æ»‘åŠ¨å¹³å‡+ä½é€šæ»¤æ³¢æå‡ä¼ æ„Ÿå™¨ç²¾åº¦
- **äº‘ç«¯ç›‘æ§**: MQTTåè®®å®æ—¶æ•°æ®ä¸Šä¼ 
- **ä»£ç è§„æ¨¡**: çº¦3500è¡ŒCä»£ç 

---

## ğŸ› ï¸ å¼€å‘ç¯å¢ƒé…ç½®

### å¿…å¤‡ç¡¬ä»¶æ¸…å•

| ç¡¬ä»¶åç§° | å‹å·/è§„æ ¼ | æ•°é‡ | ç”¨é€” |
|---------|----------|------|------|
| ä¸»æ§æ¿ | STM32F407VET6æœ€å°ç³»ç»Ÿæ¿ | 1 | æ ¸å¿ƒæ§åˆ¶å™¨ |
| è°ƒè¯•å™¨ | DAP-Link/ST-Link | 1 | ç¨‹åºçƒ§å½•ä¸è°ƒè¯• |
| ä¾›ç”µç”µæ±  | 5Vé”‚ç”µæ± ç»„ï¼ˆ2000mAh+ï¼‰ | 1 | ç³»ç»Ÿä¾›ç”µ |
| æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨ | AHT20æ¨¡å— | 1 | æ¿è½½å·²é›†æˆ |
| å§¿æ€ä¼ æ„Ÿå™¨ | ICM-20608-Gæ¨¡å— | 1 | æ¿è½½å·²é›†æˆ |
| çƒŸé›¾ä¼ æ„Ÿå™¨ | MQ2æ¨¡å— | 1 | å¤–æ¥ |
| å¿ƒç‡è¡€æ°§ | MAX30102æ¨¡å— | 1 | å¤–æ¥ |
| GPSæ¨¡å— | ATGM336H | 1 | å¤–æ¥ |
| WiFiæ¨¡å— | ESP01S + çƒ§å½•å™¨ | 1 | æ•°æ®ä¸Šäº‘ |
| è¯­éŸ³æ¨¡å— | å¤©é—®ASR-PRO | 1 | è¯­éŸ³æ§åˆ¶ |
| ç»§ç”µå™¨æ¨¡å— | åŒè·¯ç»§ç”µå™¨ | 1 | æ§åˆ¶LED/é£æ‰‡ |
| è¿æ¥çº¿æ | æœé‚¦çº¿è‹¥å¹² | 1å¥— | æ¨¡å—è¿æ¥ |

### å¿…å¤‡è½¯ä»¶å·¥å…·

| è½¯ä»¶åç§° | ç‰ˆæœ¬ | ä¸‹è½½é“¾æ¥ | ç”¨é€” |
|---------|------|---------|------|
| STM32CubeMX | 6.0+ | [å®˜ç½‘](https://www.st.com/zh/development-tools/stm32cubemx.html) | å›¾å½¢åŒ–é…ç½® |
| Keil MDK-ARM | V5.37+ | [å®˜ç½‘](https://www.keil.com/download/product/) | ä»£ç ç¼–å†™ç¼–è¯‘ |
| ä¸²å£è°ƒè¯•åŠ©æ‰‹ | ä»»æ„ | - | æŸ¥çœ‹è°ƒè¯•ä¿¡æ¯ |
| MQTTFX | 1.7.1 | [ä¸‹è½½](https://mqttfx.jensd.de/index.php/download) | MQTTæµ‹è¯• |
| å¤©é—®è¯­éŸ³å·¥ç¨‹å¸ˆ | æœ€æ–°ç‰ˆ | [å®˜ç½‘](http://twen51.com) | è¯­éŸ³é…ç½® |

---

## ğŸ“ ç³»ç»Ÿæ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  STM32F407VET6 (168MHz)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ AHT20    â”‚ ICM20608 â”‚ MQ2      â”‚ MAX30102 â”‚ ATGM336H    â”‚
â”‚ (æ¿è½½)    â”‚ (æ¿è½½)    â”‚ (çƒŸé›¾)    â”‚ (å¿ƒç‡)    â”‚ (GPS)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚           â”‚           â”‚          â”‚           â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
      â”‚           I2C1æ€»çº¿                           â”‚
      â”‚                                             UART2
 â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”                                    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
 â”‚ UART1   â”‚                                    â”‚ UART3   â”‚
 â”‚ ASR-PRO â”‚                                    â”‚ ESP01S  â”‚
 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
      â”‚                                              â”‚
      â”‚                                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
      â”‚                                         â”‚ åä¸ºäº‘IoT â”‚
      â”‚                                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
 â”‚ ç»§ç”µå™¨   â”‚
 â”‚ LED/é£æ‰‡ â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è½¯ä»¶åˆ†å±‚æ¶æ„
```
main.c
  â”‚
  â”œâ”€â”€ HALå±‚ (ç¡¬ä»¶æŠ½è±¡å±‚)
  â”‚    â”œâ”€â”€ stm32f4xx_hal_i2c.c
  â”‚    â”œâ”€â”€ stm32f4xx_hal_uart.c
  â”‚    â”œâ”€â”€ stm32f4xx_hal_adc.c
  â”‚    â””â”€â”€ stm32f4xx_hal_tim.c
  â”‚
  â”œâ”€â”€ BSPå±‚ (æ¿çº§æ”¯æŒåŒ…)
  â”‚    â”œâ”€â”€ scheduler.c         - ä»»åŠ¡è°ƒåº¦å™¨
  â”‚    â”œâ”€â”€ delay_us.c          - å¾®ç§’å»¶æ—¶
  â”‚    â””â”€â”€ printf_redirect.c   - ä¸²å£é‡å®šå‘
  â”‚
  â””â”€â”€ APPå±‚ (åº”ç”¨å±‚)
       â”œâ”€â”€ aht20.c/h           - AHT20æ¸©æ¹¿åº¦é©±åŠ¨
       â”œâ”€â”€ icm20608.c/h        - ICM-20608-Gå§¿æ€é©±åŠ¨
       â”œâ”€â”€ mq2.c/h             - MQ2çƒŸé›¾é©±åŠ¨
       â”œâ”€â”€ max30102.c/h        - MAX30102å¿ƒç‡è¡€æ°§é©±åŠ¨
       â”œâ”€â”€ atgm336h.c/h        - GPSå®šä½é©±åŠ¨
       â”œâ”€â”€ esp01s.c/h          - WiFiä¸Šäº‘é©±åŠ¨
       â”œâ”€â”€ sensor_manager.c/h  - ä¼ æ„Ÿå™¨æ ‡å¿—ç®¡ç†
       â””â”€â”€ algorithm.c/h       - å¿ƒç‡è¡€æ°§ç®—æ³•
```

---

## ğŸš€ è¯¦ç»†å¼€å‘æ­¥éª¤

### é˜¶æ®µä¸€ï¼šCubeMXå·¥ç¨‹é…ç½®ï¼ˆDay 1ï¼‰

#### Step 1: åˆ›å»ºæ–°å·¥ç¨‹
1. æ‰“å¼€STM32CubeMX
2. é€‰æ‹©MCUå‹å·: **STM32F407VETx** (LQFP100å°è£…)
3. è®¾ç½®æ—¶é’Ÿ:
   - å¤–éƒ¨æ™¶æŒ¯HSE: **8MHz**
   - ç³»ç»Ÿæ—¶é’ŸSYSCLK: **168MHz**
   - AHBæ—¶é’Ÿ: **168MHz**
   - APB1æ—¶é’Ÿ: **42MHz** (Ã·4)
   - APB2æ—¶é’Ÿ: **84MHz** (Ã·2)

#### Step 2: å¤–è®¾é…ç½®æ¸…å•

**I2C1é…ç½®ï¼ˆæ¿è½½ä¼ æ„Ÿå™¨ï¼‰**
```
å¼•è„š: PB6(SCL), PB7(SDA)
æ¨¡å¼: I2C
é€Ÿåº¦: Fast Mode (400kHz)
ç”¨é€”: ICM-20608-Gã€AHT20å…±äº«æ€»çº¿
```

**UARTé…ç½®**
```
USART1: PA9(TX), PA10(RX) - å¤©é—®è¯­éŸ³æ¨¡å—, 115200bps
USART2: PA2(TX), PA3(RX)  - GPSæ¨¡å—, 9600bps
USART3: PB10(TX), PB11(RX)- ESP01S, 115200bps
```

**ADCé…ç½®**
```
ADC1-Channel0: PA0 - MQ2çƒŸé›¾ä¼ æ„Ÿå™¨
é‡‡æ ·æ—¶é—´: 480 Cycles
å¯ç”¨DMAè¿ç»­è½¬æ¢
```

**TIM1é…ç½®ï¼ˆå¾®ç§’å»¶æ—¶ï¼‰**
```
æ—¶é’Ÿæº: Internal Clock
Prescaler: 167 (168MHz/168=1MHz â†’ 1us/tick)
Counter Period: 65535
```

**GPIOé…ç½®**
```
PB14: GPIO_Output - MAX30102 SDA (è½¯ä»¶I2C)
PB15: GPIO_Output - MAX30102 SCL (è½¯ä»¶I2C)
PB13: GPIO_Input  - MAX30102 INT
```

#### Step 3: ç”Ÿæˆä»£ç 
- é¡¹ç›®åç§°: `smart_helmet_f407`
- IDEé€‰æ‹©: **MDK-ARM V5**
- ä»£ç ç”Ÿæˆé€‰é¡¹:
  - âœ… Copy only the necessary library files
  - âœ… Generate peripheral initialization as a pair of '.c/.h' files
- ç‚¹å‡» **GENERATE CODE**

#### Step 4: Keilå·¥ç¨‹é…ç½®
1. æ‰“å¼€ç”Ÿæˆçš„ `smart_helmet_f407.uvprojx`
2. æ·»åŠ æ–°ç»„ `APP`
3. è®¾ç½®ä¼˜åŒ–çº§åˆ«: **-O2** (Options -> C/C++ -> Optimization)
4. ä½¿èƒ½ç¡¬ä»¶FPU: **Options -> C/C++ -> Use single precision**
5. æ·»åŠ å¤´æ–‡ä»¶è·¯å¾„: `../APP`

---

### é˜¶æ®µäºŒï¼šä¼ æ„Ÿå™¨é©±åŠ¨å¼€å‘ï¼ˆDay 2-8ï¼‰

#### 1. AHT20æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨ï¼ˆDay 2ï¼‰

**ç¡¬ä»¶è¿æ¥ï¼ˆæ¿è½½ï¼‰**
```
AHT20 SCL â†’ PB6 (I2C1_SCL)
AHT20 SDA â†’ PB7 (I2C1_SDA)
AHT20 VCC â†’ 3.3V
AHT20 GND â†’ GND
```

**å¼€å‘æµç¨‹**
1. åˆ›å»º `aht20.c` å’Œ `aht20.h`
2. å®ç°AHT20åˆå§‹åŒ–å‡½æ•°
```c
#define AHT20_ADDRESS 0x70  // I2Cåœ°å€ï¼ˆå†™åœ°å€ï¼‰

void AHT20_Init(void) {
    HAL_Delay(40);  // ä¸Šç”µç­‰å¾…40ms
    uint8_t cmd[3] = {0xBE, 0x08, 0x00};  // åˆå§‹åŒ–å‘½ä»¤
    HAL_I2C_Master_Transmit(&hi2c1, AHT20_ADDRESS, cmd, 3, 1000);
}
```

3. å®ç°æ¸©æ¹¿åº¦è¯»å–å‡½æ•°
```c
typedef struct {
    float temperature;  // æ¸©åº¦â„ƒ
    float humidity;     // æ¹¿åº¦%RH
} AHT20_Data_t;

HAL_StatusTypeDef AHT20_Read(AHT20_Data_t *data) {
    uint8_t cmd[3] = {0xAC, 0x33, 0x00};  // è§¦å‘æµ‹é‡
    uint8_t buf[6];

    HAL_I2C_Master_Transmit(&hi2c1, AHT20_ADDRESS, cmd, 3, 1000);
    HAL_Delay(80);  // ç­‰å¾…æµ‹é‡å®Œæˆ
    HAL_I2C_Master_Receive(&hi2c1, AHT20_ADDRESS | 0x01, buf, 6, 1000);

    // è®¡ç®—æ¹¿åº¦
    uint32_t hum_raw = ((uint32_t)buf[1] << 12) | ((uint32_t)buf[2] << 4) | (buf[3] >> 4);
    data->humidity = (float)hum_raw * 100.0f / 1048576.0f;

    // è®¡ç®—æ¸©åº¦
    uint32_t temp_raw = (((uint32_t)buf[3] & 0x0F) << 16) | ((uint32_t)buf[4] << 8) | buf[5];
    data->temperature = (float)temp_raw * 200.0f / 1048576.0f - 50.0f;

    return HAL_OK;
}
```

4. æ·»åŠ ä»»åŠ¡å‡½æ•°
```c
void aht20_task(void) {
    static AHT20_Data_t aht20_data;
    if(AHT20_Read(&aht20_data) == HAL_OK) {
        printf("Temp: %.1fÂ°C, Humi: %.1f%%\r\n",
               aht20_data.temperature, aht20_data.humidity);
    }
}
```

**æ³¨æ„äº‹é¡¹**
- AHT20ä¸Šç”µéœ€ç­‰å¾…40msæ‰èƒ½åˆå§‹åŒ–
- æ¯æ¬¡æµ‹é‡éœ€è¦80msç­‰å¾…æ—¶é—´
- I2Cåœ°å€æ˜¯0x70ï¼ˆå†™åœ°å€ï¼‰ï¼Œè¯»åœ°å€æ˜¯0x71

---

#### 2. ICM-20608-Gå§¿æ€ä¼ æ„Ÿå™¨ï¼ˆDay 3-4ï¼‰

**ç¡¬ä»¶è¿æ¥ï¼ˆæ¿è½½ï¼‰**
```
ICM20608 SCL â†’ PB6 (I2C1_SCL)
ICM20608 SDA â†’ PB7 (I2C1_SDA)
ICM20608 VCC â†’ 3.3V
ICM20608 GND â†’ GND
```

**å¼€å‘æµç¨‹**

1. **å¯„å­˜å™¨å®šä¹‰** (icm20608.h)
```c
#define ICM20608_ADDR        0xD0  // I2Cåœ°å€
#define ICM20608_PWR_MGMT_1  0x6B  // ç”µæºç®¡ç†1
#define ICM20608_GYRO_CONFIG 0x1B  // é™€èºä»ªé…ç½®
#define ICM20608_ACCEL_CONFIG 0x1C // åŠ é€Ÿåº¦è®¡é…ç½®
#define ICM20608_ACCEL_XOUT_H 0x3B // åŠ é€Ÿåº¦Xé«˜å­—èŠ‚
#define ICM20608_GYRO_XOUT_H  0x43 // é™€èºä»ªXé«˜å­—èŠ‚
```

2. **åˆå§‹åŒ–å‡½æ•°**
```c
void ICM20608_Init(void) {
    uint8_t data;

    // å¤ä½è®¾å¤‡
    data = 0x80;
    HAL_I2C_Mem_Write(&hi2c1, ICM20608_ADDR, ICM20608_PWR_MGMT_1, 1, &data, 1, 1000);
    HAL_Delay(100);

    // å”¤é†’è®¾å¤‡
    data = 0x00;
    HAL_I2C_Mem_Write(&hi2c1, ICM20608_ADDR, ICM20608_PWR_MGMT_1, 1, &data, 1, 1000);

    // é™€èºä»ªé‡ç¨‹Â±2000Â°/s
    data = 0x18;
    HAL_I2C_Mem_Write(&hi2c1, ICM20608_ADDR, ICM20608_GYRO_CONFIG, 1, &data, 1, 1000);

    // åŠ é€Ÿåº¦è®¡é‡ç¨‹Â±16g
    data = 0x18;
    HAL_I2C_Mem_Write(&hi2c1, ICM20608_ADDR, ICM20608_ACCEL_CONFIG, 1, &data, 1, 1000);
}
```

3. **æ•°æ®è¯»å–å‡½æ•°**
```c
typedef struct {
    int16_t accel_x, accel_y, accel_z;  // åŠ é€Ÿåº¦åŸå§‹å€¼
    int16_t gyro_x, gyro_y, gyro_z;     // é™€èºä»ªåŸå§‹å€¼
    float pitch, roll, yaw;              // æ¬§æ‹‰è§’
} ICM20608_Data_t;

void ICM20608_ReadAccelGyro(ICM20608_Data_t *data) {
    uint8_t buf[14];
    HAL_I2C_Mem_Read(&hi2c1, ICM20608_ADDR, ICM20608_ACCEL_XOUT_H, 1, buf, 14, 1000);

    // åŠ é€Ÿåº¦æ•°æ®
    data->accel_x = (int16_t)((buf[0] << 8) | buf[1]);
    data->accel_y = (int16_t)((buf[2] << 8) | buf[3]);
    data->accel_z = (int16_t)((buf[4] << 8) | buf[5]);

    // é™€èºä»ªæ•°æ®
    data->gyro_x = (int16_t)((buf[8] << 8) | buf[9]);
    data->gyro_y = (int16_t)((buf[10] << 8) | buf[11]);
    data->gyro_z = (int16_t)((buf[12] << 8) | buf[13]);
}
```

4. **å§¿æ€è§£ç®—ï¼ˆäº’è¡¥æ»¤æ³¢ï¼‰**
```c
void ICM20608_Calculate_Angle(ICM20608_Data_t *data) {
    // åŠ é€Ÿåº¦è®¡è®¡ç®—è§’åº¦ï¼ˆé™æ€è§’åº¦ï¼‰
    float acc_pitch = atan2(data->accel_y, data->accel_z) * 57.3f;
    float acc_roll = atan2(-data->accel_x, sqrt(data->accel_y*data->accel_y + data->accel_z*data->accel_z)) * 57.3f;

    // é™€èºä»ªç§¯åˆ†ï¼ˆåŠ¨æ€è§’åº¦ï¼‰
    float dt = 0.01f;  // 10msé‡‡æ ·å‘¨æœŸ
    data->pitch += data->gyro_x * dt / 16.4f;  // Â±2000Â°/sé‡ç¨‹ä¸‹ï¼Œçµæ•åº¦16.4 LSB/(Â°/s)
    data->roll  += data->gyro_y * dt / 16.4f;

    // äº’è¡¥æ»¤æ³¢èåˆ
    float alpha = 0.98f;
    data->pitch = alpha * data->pitch + (1-alpha) * acc_pitch;
    data->roll = alpha * data->roll + (1-alpha) * acc_roll;
}
```

5. **æ‘”å€’æ£€æµ‹é€»è¾‘**
```c
bool fall_flag = false;

void icm20608_task(void) {
    static ICM20608_Data_t icm_data;

    ICM20608_ReadAccelGyro(&icm_data);
    ICM20608_Calculate_Angle(&icm_data);

    // æ£€æµ‹æ‘”å€’ï¼šä»»æ„è½´å€¾æ–œè¶…è¿‡60åº¦
    if(fabs(icm_data.pitch) > 60.0f || fabs(icm_data.roll) > 60.0f) {
        fall_flag = true;
    } else {
        fall_flag = false;
    }

    printf("Pitch: %.1fÂ°, Roll: %.1fÂ°, Fall: %d\r\n",
           icm_data.pitch, icm_data.roll, fall_flag);
}
```

**å…³é”®æŠ€æœ¯ç‚¹**
- **äº’è¡¥æ»¤æ³¢**: èåˆåŠ é€Ÿåº¦è®¡çš„é™æ€ç²¾åº¦å’Œé™€èºä»ªçš„åŠ¨æ€å“åº”
- **æ‘”å€’åˆ¤æ–­**: pitchæˆ–rollè¶…è¿‡60Â°å³è®¤ä¸ºæ‘”å€’
- **I2Cåœ°å€**: 0xD0ï¼ˆAD0å¼•è„šæ¥åœ°æ—¶ï¼‰

---

#### 3. MQ2çƒŸé›¾ä¼ æ„Ÿå™¨ï¼ˆDay 5ï¼‰

**ç¡¬ä»¶è¿æ¥**
```
MQ2 AO  â†’ PA0 (ADC1_IN0)
MQ2 VCC â†’ 5V (å¤–éƒ¨ä¾›ç”µï¼)
MQ2 GND â†’ GND
```

**å¼€å‘æµç¨‹**

1. **ADC+DMAé…ç½®**
åœ¨CubeMXä¸­å·²é…ç½®ADC1+DMAï¼Œåœ¨main.cä¸­å¯åŠ¨ï¼š
```c
uint32_t adc_buffer[30];  // DMAç¼“å†²åŒº

// USER CODE BEGIN 2
HAL_ADC_Start_DMA(&hadc1, adc_buffer, 30);
// USER CODE END 2
```

2. **æµ“åº¦è®¡ç®—å‡½æ•°** (mq2.c)
```c
#define RL 4.7f   // è´Ÿè½½ç”µé˜»4.7kÎ©
#define R0 35.9f  // æ¸…æ´ç©ºæ°”ä¸­çš„ä¼ æ„Ÿå™¨ç”µé˜»ï¼ˆéœ€æ ¡å‡†ï¼‰

float MQ2_Calculate_PPM(void) {
    // æ±‚å¹³å‡ADCå€¼
    uint32_t adc_sum = 0;
    for(int i = 0; i < 30; i++) {
        adc_sum += adc_buffer[i];
    }
    float adc_avg = adc_sum / 30.0f;

    // è½¬æ¢ä¸ºç”µå‹
    float voltage = adc_avg * 3.3f / 4095.0f;

    // è®¡ç®—ä¼ æ„Ÿå™¨ç”µé˜»Rs
    float Rs = ((5.0f - voltage) / voltage) * RL;

    // è®¡ç®—ppmæµ“åº¦ï¼ˆçƒŸé›¾æ›²çº¿ï¼‰
    float ppm = pow((Rs / (R0 * 11.5428f)), -1.5278f);

    return ppm;
}
```

3. **ä»»åŠ¡å‡½æ•°**
```c
bool density_flag = false;  // æµ“åº¦æŠ¥è­¦æ ‡å¿—

void mq2_task(void) {
    static float ppm;
    ppm = MQ2_Calculate_PPM();

    // åˆ¤æ–­æ˜¯å¦è¶…æ ‡
    density_flag = (ppm > 100.0f);

    printf("MQ2: %.2f ppm, Alarm: %d\r\n", ppm, density_flag);
}
```

**å…³é”®æ³¨æ„äº‹é¡¹**
- âš ï¸ **MQ2å¿…é¡»å¤–éƒ¨5Vä¾›ç”µ**ï¼ŒSTM32çš„5Vå¼•è„šç”µå‹ä¸è¶³
- é¢„çƒ­1-2åˆ†é’Ÿæ•°æ®æ‰ç¨³å®š
- R0éœ€è¦åœ¨æ¸…æ´ç¯å¢ƒä¸­æ ¡å‡†ï¼š`R0 = ((5-V)/V) * RL`

---

#### 4. MAX30102å¿ƒç‡è¡€æ°§ä¼ æ„Ÿå™¨ï¼ˆDay 6-7ï¼‰

**ç¡¬ä»¶è¿æ¥**
```
MAX30102 SCL â†’ PB15 (è½¯ä»¶I2C)
MAX30102 SDA â†’ PB14 (è½¯ä»¶I2C)
MAX30102 INT â†’ PB13 (GPIO_Input)
MAX30102 VCC â†’ 5V
MAX30102 GND â†’ GND
```

**å¼€å‘æµç¨‹**

1. **è½¯ä»¶I2Cå®ç°** (myiic.c)
```c
#define MAX30102_SCL_PIN GPIO_PIN_15
#define MAX30102_SDA_PIN GPIO_PIN_14
#define MAX30102_PORT    GPIOB

// å»¶æ—¶å‡½æ•°ï¼ˆåŸºäºTIM1ï¼Œ1usç²¾åº¦ï¼‰
void delay_us(uint16_t us) {
    __HAL_TIM_SET_COUNTER(&htim1, 0xFFFF - us - 5);
    HAL_TIM_Base_Start(&htim1);
    while(__HAL_TIM_GET_COUNTER(&htim1) < 0xFFFF - 5);
    HAL_TIM_Base_Stop(&htim1);
}

// I2Cèµ·å§‹ä¿¡å·
void I2C_Start(void) {
    SDA_OUT();
    HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SDA_PIN, GPIO_PIN_SET);
    HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SCL_PIN, GPIO_PIN_SET);
    delay_us(4);
    HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SDA_PIN, GPIO_PIN_RESET);
    delay_us(4);
    HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SCL_PIN, GPIO_PIN_RESET);
}

// I2Cåœæ­¢ä¿¡å·
void I2C_Stop(void) {
    SDA_OUT();
    HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SCL_PIN, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SDA_PIN, GPIO_PIN_RESET);
    delay_us(4);
    HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SCL_PIN, GPIO_PIN_SET);
    HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SDA_PIN, GPIO_PIN_SET);
    delay_us(4);
}

// å‘é€ä¸€ä¸ªå­—èŠ‚
void I2C_Send_Byte(uint8_t data) {
    SDA_OUT();
    HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SCL_PIN, GPIO_PIN_RESET);
    for(int i = 0; i < 8; i++) {
        if(data & 0x80) {
            HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SDA_PIN, GPIO_PIN_SET);
        } else {
            HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SDA_PIN, GPIO_PIN_RESET);
        }
        data <<= 1;
        delay_us(2);
        HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SCL_PIN, GPIO_PIN_SET);
        delay_us(2);
        HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SCL_PIN, GPIO_PIN_RESET);
        delay_us(2);
    }
}

// è¯»å–ä¸€ä¸ªå­—èŠ‚
uint8_t I2C_Read_Byte(uint8_t ack) {
    uint8_t data = 0;
    SDA_IN();
    for(int i = 0; i < 8; i++) {
        HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SCL_PIN, GPIO_PIN_RESET);
        delay_us(2);
        HAL_GPIO_WritePin(MAX30102_PORT, MAX30102_SCL_PIN, GPIO_PIN_SET);
        data <<= 1;
        if(HAL_GPIO_ReadPin(MAX30102_PORT, MAX30102_SDA_PIN)) {
            data++;
        }
        delay_us(1);
    }
    if(!ack) I2C_NAck();
    else I2C_Ack();
    return data;
}
```

2. **MAX30102åˆå§‹åŒ–** (max30102.c)
```c
#define MAX30102_ADDR 0xAE  // I2Cå†™åœ°å€

void MAX30102_Init(void) {
    MAX30102_Reset();  // å¤ä½

    // ä¸­æ–­ä½¿èƒ½
    MAX30102_Write_Reg(REG_INTR_ENABLE_1, 0xC0);
    MAX30102_Write_Reg(REG_INTR_ENABLE_2, 0x00);

    // FIFOé…ç½®
    MAX30102_Write_Reg(REG_FIFO_WR_PTR, 0x00);
    MAX30102_Write_Reg(REG_FIFO_RD_PTR, 0x00);
    MAX30102_Write_Reg(REG_FIFO_CONFIG, 0x0F);  // å¹³å‡4æ¬¡

    // SpO2æ¨¡å¼
    MAX30102_Write_Reg(REG_MODE_CONFIG, 0x03);

    // SPO2é…ç½®ï¼šADC=4096, é‡‡æ ·ç‡100Hz, è„‰å®½400us
    MAX30102_Write_Reg(REG_SPO2_CONFIG, 0x27);

    // LEDç”µæµï¼š7mA
    MAX30102_Write_Reg(REG_LED1_PA, 0x24);  // çº¢å…‰
    MAX30102_Write_Reg(REG_LED2_PA, 0x24);  // çº¢å¤–
}
```

3. **æ•°æ®é‡‡é›†ä¸ç®—æ³•** (max30102_app.c)
```c
#define BUFFER_LENGTH 500

typedef struct {
    uint32_t red_buffer[BUFFER_LENGTH];
    uint32_t ir_buffer[BUFFER_LENGTH];
    int32_t heart_rate;
    int32_t spO2;
    int8_t hr_valid;
    int8_t spo2_valid;
} MAX30102_Data_t;

void MAX30102_Read_Samples(MAX30102_Data_t *data) {
    uint8_t temp[6];
    for(int i = 0; i < BUFFER_LENGTH; i++) {
        // ç­‰å¾…æ•°æ®å°±ç»ª
        while(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13) == GPIO_PIN_SET);

        // è¯»å–FIFO
        MAX30102_Read_FIFO(temp);
        data->red_buffer[i] = ((uint32_t)temp[0] << 16) | ((uint32_t)temp[1] << 8) | temp[2];
        data->ir_buffer[i] = ((uint32_t)temp[3] << 16) | ((uint32_t)temp[4] << 8) | temp[5];
    }
}

void MAX30102_Calculate(MAX30102_Data_t *data) {
    // è°ƒç”¨Maximå®˜æ–¹ç®—æ³•
    maxim_heart_rate_and_oxygen_saturation(
        data->ir_buffer, BUFFER_LENGTH,
        data->red_buffer,
        &data->spO2, &data->spo2_valid,
        &data->heart_rate, &data->hr_valid
    );

    // å¿ƒç‡è¡¥å¿
    data->heart_rate += 10;
}
```

4. **å¤šçº§æ»¤æ³¢ä¼˜åŒ–** (algorithm.c)
```c
#define WINDOW_SIZE 20
#define ALPHA 0.05f

int hr_buffer[WINDOW_SIZE] = {0};
int spo2_buffer[WINDOW_SIZE] = {0};
int hr_index = 0, spo2_index = 0;

// æ»‘åŠ¨å¹³å‡æ»¤æ³¢
int Smooth_Data(int new_value, int *buffer, int *index) {
    buffer[*index] = new_value;
    *index = (*index + 1) % WINDOW_SIZE;

    int sum = 0;
    for(int i = 0; i < WINDOW_SIZE; i++) {
        sum += buffer[i];
    }
    return sum / WINDOW_SIZE;
}

// ä½é€šæ»¤æ³¢
int LowPass_Filter(int new_value, int prev_value) {
    return (int)(ALPHA * new_value + (1-ALPHA) * prev_value);
}

void Filter_HeartRate(MAX30102_Data_t *data) {
    static int prev_hr = 0, prev_spo2 = 0;

    // æ»‘åŠ¨å¹³å‡
    data->heart_rate = Smooth_Data(data->heart_rate, hr_buffer, &hr_index);
    data->spO2 = Smooth_Data(data->spO2, spo2_buffer, &spo2_index);

    // ä½é€šæ»¤æ³¢
    data->heart_rate = LowPass_Filter(data->heart_rate, prev_hr);
    data->spO2 = LowPass_Filter(data->spO2, prev_spo2);

    prev_hr = data->heart_rate;
    prev_spo2 = data->spO2;
}
```

5. **ä»»åŠ¡å‡½æ•°**
```c
bool heartrate_flag = false;
bool spo2_flag = false;
uint8_t dis_hr = 0, dis_spo2 = 0;

void max30102_task(void) {
    static MAX30102_Data_t max_data;

    // é‡‡é›†500ä¸ªæ ·æœ¬ï¼ˆçº¦5ç§’ï¼‰
    MAX30102_Read_Samples(&max_data);

    // è®¡ç®—å¿ƒç‡è¡€æ°§
    MAX30102_Calculate(&max_data);

    // æ»¤æ³¢
    Filter_HeartRate(&max_data);

    // åˆ¤æ–­æœ‰æ•ˆæ€§
    if(max_data.hr_valid && max_data.heart_rate < 120) {
        dis_hr = max_data.heart_rate;
        dis_spo2 = max_data.spO2;
    }

    // å¼‚å¸¸åˆ¤æ–­
    heartrate_flag = (dis_hr < 60 || dis_hr > 100);
    spo2_flag = (dis_spo2 < 95);

    printf("HR: %d bpm, SpO2: %d%%, HR_Alarm: %d, SpO2_Alarm: %d\r\n",
           dis_hr, dis_spo2, heartrate_flag, spo2_flag);
}
```

**å…³é”®æŠ€æœ¯ç‚¹**
- **è½¯ä»¶I2C**: çµæ´»ä½†éœ€è¦ç²¾ç¡®çš„usçº§å»¶æ—¶
- **500æ ·æœ¬**: é‡‡é›†çº¦5ç§’æ•°æ®ä¿è¯ç®—æ³•ç²¾åº¦
- **å¤šçº§æ»¤æ³¢**: æ»‘åŠ¨å¹³å‡+ä½é€šæ»¤æ³¢å¤§å¹…é™ä½å™ªå£°
- **å¿ƒç‡è¡¥å¿**: +10bpmä¿®æ­£ç®—æ³•ç³»ç»Ÿæ€§åä½

---

#### 5. ATGM336H GPSæ¨¡å—ï¼ˆDay 8ï¼‰

**ç¡¬ä»¶è¿æ¥**
```
ATGM336H RX  â†’ PA2 (USART2_TX)
ATGM336H TX  â†’ PA3 (USART2_RX)
ATGM336H VCC â†’ 5V
ATGM336H GND â†’ GND
```

**å¼€å‘æµç¨‹**

1. **UARTä¸­æ–­æ¥æ”¶é…ç½®**
åœ¨main.cä¸­å¯åŠ¨ä¸­æ–­æ¥æ”¶ï¼š
```c
uint8_t uart2_rx_byte;

// USER CODE BEGIN 2
HAL_UART_Receive_IT(&huart2, &uart2_rx_byte, 1);
// USER CODE END 2
```

2. **NMEAæ•°æ®è§£æ** (atgm336h.c)
```c
#define USART_REC_LEN 200

typedef struct {
    char gps_buffer[USART_REC_LEN];
    char utc_time[11];
    char latitude[11];
    char N_S[2];
    char longitude[12];
    char E_W[2];
    uint8_t is_valid;
} GPS_Data_t;

GPS_Data_t gps_data;
float latitude_decimal = 0.0f;
float longitude_decimal = 0.0f;

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    static uint16_t index = 0;

    if(huart->Instance == USART2) {
        // æ£€æµ‹å¸§å¤´
        if(uart2_rx_byte == '$') {
            index = 0;
        }

        gps_data.gps_buffer[index++] = uart2_rx_byte;

        // æ£€æµ‹$GNRMCå¸§
        if(gps_data.gps_buffer[0] == '$' &&
           gps_data.gps_buffer[4] == 'M' &&
           gps_data.gps_buffer[5] == 'C') {

            // æ£€æµ‹å¸§å°¾
            if(uart2_rx_byte == '\n') {
                gps_data.gps_buffer[index] = '\0';
                gps_data.is_valid = 1;
                index = 0;
            }
        }

        // ç»§ç»­æ¥æ”¶
        HAL_UART_Receive_IT(&huart2, &uart2_rx_byte, 1);
    }
}

void GPS_Parse_NMEA(void) {
    if(!gps_data.is_valid) return;
    gps_data.is_valid = 0;

    char *token;
    char *fields[15];
    int i = 0;

    // åˆ†å‰²å­—æ®µ
    token = strtok(gps_data.gps_buffer, ",");
    while(token != NULL && i < 15) {
        fields[i++] = token;
        token = strtok(NULL, ",");
    }

    // æ£€æŸ¥æœ‰æ•ˆæ€§æ ‡å¿—
    if(i > 2 && fields[2][0] == 'A') {
        // è§£æçº¬åº¦
        strcpy(gps_data.latitude, fields[3]);
        strcpy(gps_data.N_S, fields[4]);

        // è§£æç»åº¦
        strcpy(gps_data.longitude, fields[5]);
        strcpy(gps_data.E_W, fields[6]);

        // è½¬æ¢ä¸ºåè¿›åˆ¶åº¦æ•°
        int lat_deg = (int)(atof(gps_data.latitude) / 100);
        float lat_min = atof(gps_data.latitude) - lat_deg * 100;
        latitude_decimal = lat_deg + lat_min / 60.0f;

        int lon_deg = (int)(atof(gps_data.longitude) / 100);
        float lon_min = atof(gps_data.longitude) - lon_deg * 100;
        longitude_decimal = lon_deg + lon_min / 60.0f;

        // å¤„ç†å—åŒ—çº¬ã€ä¸œè¥¿ç»
        if(gps_data.N_S[0] == 'S') latitude_decimal = -latitude_decimal;
        if(gps_data.E_W[0] == 'W') longitude_decimal = -longitude_decimal;
    }
}

void atgm336h_task(void) {
    GPS_Parse_NMEA();
    printf("GPS: Lat=%.6f%c, Lon=%.6f%c\r\n",
           fabs(latitude_decimal), gps_data.N_S[0],
           fabs(longitude_decimal), gps_data.E_W[0]);
}
```

**å…³é”®æ³¨æ„äº‹é¡¹**
- GPSéœ€è¦åœ¨**å®¤å¤–ç©ºæ—·å¤„**æ‰èƒ½å®šä½
- å†·å¯åŠ¨éœ€è¦1-3åˆ†é’Ÿ
- è§£æ$GNRMCæˆ–$GNGGAå‡å¯
- åæ ‡æ ¼å¼ï¼šDDMM.MMMMéœ€è½¬æ¢ä¸ºDD.DDDDDD

---

### é˜¶æ®µä¸‰ï¼šè¯­éŸ³æ§åˆ¶ä¸æŠ¥è­¦ï¼ˆDay 9-10ï¼‰

#### å¤©é—®ASR-PROé…ç½®

**ç¡¬ä»¶è¿æ¥**
```
ASR-PRO PA2 â†’ STM32 PA10 (USART1_RX)
ASR-PRO PA3 â†’ STM32 PA9  (USART1_TX)
ASR-PRO 5V  â†’ å¤–éƒ¨5V
ASR-PRO GND â†’ GND
```

**è½¯ä»¶é…ç½®ï¼ˆå¤©é—®è¯­éŸ³å·¥ç¨‹å¸ˆï¼‰**

1. **è¯æ¡é…ç½®**
- æ‰“å¼€"è¯­éŸ³å·¥ç¨‹å¸ˆ"è½¯ä»¶
- æ–°å»ºå·¥ç¨‹ â†’ é€‰æ‹©ASR-PROå‹å·
- æ·»åŠ æ§åˆ¶è¯æ¡ï¼š

| è¯æ¡å†…å®¹ | è¯†åˆ«ID | è§¦å‘åŠ¨ä½œ | å¤‡æ³¨ |
|---------|-------|---------|------|
| æ‰“å¼€ç”µç¯ | 0x01 | æ§åˆ¶PA6é«˜ç”µå¹³ | ç»§ç”µå™¨1 |
| å…³é—­ç”µç¯ | 0x02 | æ§åˆ¶PA6ä½ç”µå¹³ | ç»§ç”µå™¨1 |
| æ‰“å¼€é£æ‰‡ | 0x03 | æ§åˆ¶PA5é«˜ç”µå¹³ | ç»§ç”µå™¨2 |
| å…³é—­é£æ‰‡ | 0x04 | æ§åˆ¶PA5ä½ç”µå¹³ | ç»§ç”µå™¨2 |
| æµ‹é‡å¿ƒç‡ | 0x05 | å‘é€"measure\r\n" | ä¸²å£å‘é€ |
| å–æ¶ˆæŠ¥è­¦ | 0x06 | å‘é€"good\r\n" | ä¸²å£å‘é€ |

- æ·»åŠ æ’­æŠ¥è¯æ¡ï¼š

| è¯æ¡å†…å®¹ | è¯†åˆ«ID | è§¦å‘æ¡ä»¶ | å¤‡æ³¨ |
|---------|-------|---------|------|
| æ£€æµ‹åˆ°è·Œå€’ | 0x10 | æ”¶åˆ°"fall" | æ‘”å€’æŠ¥è­¦ |
| æ£€æµ‹åˆ°æµ“åº¦è¿‡é«˜ | 0x11 | æ”¶åˆ°"density" | çƒŸé›¾æŠ¥è­¦ |
| å¿ƒç‡å¼‚å¸¸ | 0x12 | æ”¶åˆ°"heartrate" | å¿ƒç‡æŠ¥è­¦ |
| è¡€æ°§å¼‚å¸¸ | 0x13 | æ”¶åˆ°"spo2" | è¡€æ°§æŠ¥è­¦ |

2. **çƒ§å½•åˆ°æ¨¡å—**
- è¿æ¥ASR-PROçƒ§å½•å™¨
- ç‚¹å‡»"çƒ§å½•"æŒ‰é’®
- ç­‰å¾…å®Œæˆæç¤º

**STM32ä¸è¯­éŸ³æ¨¡å—é€šä¿¡** (sensor.c)
```c
bool alarm_cancel_flag = false;
bool measure_flag = false;
uint8_t alarm_cancel_count = 0;

// å¤„ç†è¯­éŸ³è¯†åˆ«æ•°æ®
void process_asr_data(void) {
    static uint8_t uart1_rx_buffer[20];
    static uint16_t uart1_rx_index = 0;
    static uint32_t uart1_rx_ticks = 0;

    // æ¥æ”¶è¶…æ—¶åˆ¤æ–­ï¼ˆ10msæ— æ–°æ•°æ®ï¼‰
    if(uart1_rx_index > 0 && HAL_GetTick() - uart1_rx_ticks > 10) {
        uart1_rx_buffer[uart1_rx_index] = '\0';

        // è§£ææŒ‡ä»¤
        if(strcmp((char*)uart1_rx_buffer, "good\r\n") == 0) {
            alarm_cancel_flag = true;
            alarm_cancel_count = 10;  // 10ç§’æœ‰æ•ˆæœŸ
        } else if(strcmp((char*)uart1_rx_buffer, "measure\r\n") == 0) {
            measure_flag = true;
        }

        // æ¸…ç©ºç¼“å†²åŒº
        uart1_rx_index = 0;
    }
}

// å‘è¯­éŸ³æ¨¡å—å‘é€æŠ¥è­¦æŒ‡ä»¤
void send_flag_to_asr(void) {
    if(alarm_cancel_flag) {
        // æŠ¥è­¦å–æ¶ˆæœŸé—´ï¼Œè®¡æ•°å™¨é€’å‡
        if(--alarm_cancel_count == 0) {
            alarm_cancel_flag = false;
        }
        return;  // ä¸å‘é€æŠ¥è­¦
    }

    // æ£€æµ‹å„ç§å¼‚å¸¸å¹¶å‘é€å¯¹åº”æŒ‡ä»¤
    if(fall_flag) {
        HAL_UART_Transmit(&huart1, (uint8_t*)"fall", 4, 100);
    } else if(density_flag) {
        HAL_UART_Transmit(&huart1, (uint8_t*)"density", 7, 100);
    } else if(heartrate_flag) {
        HAL_UART_Transmit(&huart1, (uint8_t*)"heartrate", 9, 100);
        heartrate_flag = false;  // å‘é€åæ¸…é›¶
    } else if(spo2_flag) {
        HAL_UART_Transmit(&huart1, (uint8_t*)"spo2", 4, 100);
        spo2_flag = false;
    }
}
```

---

### é˜¶æ®µå››ï¼šæ•°æ®ä¸Šäº‘ï¼ˆDay 11-12ï¼‰

#### åä¸ºäº‘IoTå¹³å°é…ç½®

1. **æ³¨å†Œåä¸ºäº‘è´¦å·å¹¶å®åè®¤è¯**
   - è®¿é—® https://www.huaweicloud.com
   - æ³¨å†Œå¹¶å®Œæˆå®åè®¤è¯

2. **åˆ›å»ºIoTäº§å“**
   - è¿›å…¥æ§åˆ¶å° â†’ IoTè®¾å¤‡æ¥å…¥ â†’ äº§å“
   - ç‚¹å‡»"åˆ›å»ºäº§å“"
   - å¡«å†™ä¿¡æ¯ï¼š
     - äº§å“åç§°: `SmartHelmet`
     - åè®®ç±»å‹: `MQTT`
     - æ•°æ®æ ¼å¼: `JSON`
     - å‚å•†åç§°: `è‡ªå®šä¹‰`

3. **å®šä¹‰äº§å“æ¨¡å‹**
åœ¨"æ¨¡å‹å®šä¹‰"ä¸­æ·»åŠ ä»¥ä¸‹å±æ€§ï¼š

| å±æ€§åç§° | æ ‡è¯†ç¬¦ | æ•°æ®ç±»å‹ | å–å€¼èŒƒå›´ | å•ä½ | è¯»å†™ç±»å‹ |
|---------|-------|---------|---------|------|---------|
| ç»åº¦ | longitude | float | -180~180 | Â° | åªè¯» |
| çº¬åº¦ | latitude | float | -90~90 | Â° | åªè¯» |
| æ¸©åº¦ | temperature | int | -40~85 | â„ƒ | åªè¯» |
| æ¹¿åº¦ | humidity | int | 0~100 | %RH | åªè¯» |
| çƒŸé›¾æµ“åº¦ | propane_concentration | float | 0~1000 | ppm | åªè¯» |
| å¿ƒç‡ | heart_rate | int | 0~200 | bpm | åªè¯» |
| è¡€æ°§ | spO2 | int | 0~100 | % | åªè¯» |
| è·Œå€’æ ‡å¿— | fall_flag | int | 0~1 | - | åªè¯» |

4. **æ³¨å†Œè®¾å¤‡**
   - è¿›å…¥"è®¾å¤‡" â†’ "æ‰€æœ‰è®¾å¤‡" â†’ "æ³¨å†Œè®¾å¤‡"
   - è®¾å¤‡åç§°: `smart_helmet_1`
   - å¯†é’¥: è‡ªåŠ¨ç”Ÿæˆ
   - ä¿å­˜**è®¾å¤‡IDã€å¯†é’¥**

5. **è·å–MQTTè¿æ¥å‚æ•°**
   - ç‚¹å‡»è®¾å¤‡è¯¦æƒ… â†’ "MQTTå‚æ•°"
   - è®°å½•ä»¥ä¸‹ä¿¡æ¯ï¼š
     - **æœåŠ¡å™¨åœ°å€**: `xxxx.iot-mqtts.cn-north-4.myhuaweicloud.com`
     - **ç«¯å£**: `1883` (MQTT) æˆ– `8883` (MQTTS)
     - **ClientID**: `{ProductID}_{NodeId}_0_0_2025031607`
     - **Username**: `{DeviceID}`
     - **Password**: `{è®¾å¤‡å¯†é’¥}`

6. **æµ‹è¯•è¿æ¥ï¼ˆä½¿ç”¨MQTTFXï¼‰**
   - æ‰“å¼€MQTTFX
   - æ–°å»ºè¿æ¥é…ç½®ï¼š
     - Broker Address: åä¸ºäº‘æœåŠ¡å™¨åœ°å€
     - Port: 1883
     - Client ID: ä¸Šé¢çš„ClientID
     - User Credentials: Usernameå’ŒPassword
   - ç‚¹å‡»"Connect"ï¼Œè¿æ¥æˆåŠŸåçŠ¶æ€æ å˜ç»¿

7. **æµ‹è¯•æ•°æ®ä¸ŠæŠ¥**
   - è®¢é˜…ä¸»é¢˜: `$oc/devices/{DeviceID}/sys/properties/report`
   - å‘å¸ƒæµ‹è¯•æ•°æ®ï¼š
```json
{
    "services": [{
        "service_id": "BasicData",
        "properties": {
            "longitude": 116.3975,
            "latitude": 39.9087,
            "temperature": 25,
            "humidity": 60,
            "propane_concentration": 0.05,
            "heart_rate": 75,
            "spO2": 98,
            "fall_flag": 0
        }
    }]
}
```

#### ESP01S WiFiæ¨¡å—é…ç½®

**ç¡¬ä»¶è¿æ¥**
```
ESP01S RX  â†’ PB10 (USART3_TX)
ESP01S TX  â†’ PB11 (USART3_RX)
ESP01S VCC â†’ 3.3V (å¤–éƒ¨ç¨³å‹ä¾›ç”µï¼)
ESP01S GND â†’ GND
```

**ATæŒ‡ä»¤é…ç½®æµç¨‹**

1. **ä½¿ç”¨ä¸²å£åŠ©æ‰‹æµ‹è¯•ESP01S**
   - è¿æ¥ESP01Sçƒ§å½•å™¨åˆ°ç”µè„‘
   - æ‰“å¼€ä¸²å£åŠ©æ‰‹ï¼ˆ115200bpsï¼‰
   - å‘é€ `AT\r\n`ï¼Œåº”è¿”å› `OK`

2. **é…ç½®WiFiè¿æ¥**
```
AT+RST\r\n                                   // å¤ä½æ¨¡å—
AT+CWMODE=1\r\n                              // è®¾ç½®STAæ¨¡å¼
AT+CWJAP="WiFiåç§°","WiFiå¯†ç "\r\n            // è¿æ¥WiFi
```

3. **é…ç½®MQTT**
```
// è®¾ç½®MQTTç”¨æˆ·ä¿¡æ¯
AT+MQTTUSERCFG=0,1,"NULL","Username","Password",0,0,""\r\n

// è®¾ç½®ClientID
AT+MQTTCLIENTID=0,"ClientID"\r\n

// è¿æ¥MQTTæœåŠ¡å™¨
AT+MQTTCONN=0,"æœåŠ¡å™¨åœ°å€",1883,1\r\n

// å‘å¸ƒæ•°æ®æµ‹è¯•
AT+MQTTPUB=0,"$oc/devices/DeviceID/sys/properties/report","JSONæ•°æ®",0,0\r\n
```

**STM32é©±åŠ¨ä»£ç ** (esp01s.c)
```c
#define WIFI_SSID "ä½ çš„WiFiåç§°"
#define WIFI_PWD  "ä½ çš„WiFiå¯†ç "
#define MQTT_SERVER   "xxxx.iot-mqtts.cn-north-4.myhuaweicloud.com"
#define MQTT_CLIENT_ID "ProductID_NodeId_0_0_2025031607"
#define MQTT_USERNAME  "DeviceID"
#define MQTT_PASSWORD  "è®¾å¤‡å¯†é’¥"
#define MQTT_TOPIC     "$oc/devices/DeviceID/sys/properties/report"

// ESP01Såˆå§‹åŒ–
void ESP01S_Init(void) {
    // å¤ä½
    my_printf(&huart3, "AT+RST\r\n");
    HAL_Delay(1000);

    // è®¾ç½®STAæ¨¡å¼
    my_printf(&huart3, "AT+CWMODE=1\r\n");
    HAL_Delay(1000);

    // è¿æ¥WiFi
    my_printf(&huart3, "AT+CWJAP=\"%s\",\"%s\"\r\n", WIFI_SSID, WIFI_PWD);
    HAL_Delay(4000);

    // é…ç½®MQTTç”¨æˆ·
    my_printf(&huart3, "AT+MQTTUSERCFG=0,1,\"NULL\",\"%s\",\"%s\",0,0,\"\"\r\n",
              MQTT_USERNAME, MQTT_PASSWORD);
    HAL_Delay(1000);

    // è®¾ç½®ClientID
    my_printf(&huart3, "AT+MQTTCLIENTID=0,\"%s\"\r\n", MQTT_CLIENT_ID);
    HAL_Delay(1000);

    // è¿æ¥MQTTæœåŠ¡å™¨
    my_printf(&huart3, "AT+MQTTCONN=0,\"%s\",1883,1\r\n", MQTT_SERVER);
    HAL_Delay(1000);
}

// æ•°æ®ä¸ŠæŠ¥å‡½æ•°1ï¼ˆä¼ æ„Ÿå™¨æ•°æ®ï¼‰
void esp_report1(void) {
    char json[256];
    snprintf(json, sizeof(json),
        "{\\\"services\\\":[{\\\"service_id\\\":\\\"BasicData\\\"\\,"
        "\\\"properties\\\":{\\\"spO2\\\":%d\\,\\\"propane_concentration\\\":%.2f\\,"
        "\\\"heart_rate\\\":%d\\,\\\"fall_flag\\\":%d}}]}",
        dis_spo2, ppm, dis_hr, fall_flag);

    my_printf(&huart3, "AT+MQTTPUB=0,\"%s\",\"%s\",0,0\r\n", MQTT_TOPIC, json);
}

// æ•°æ®ä¸ŠæŠ¥å‡½æ•°2ï¼ˆç¯å¢ƒæ•°æ®ï¼‰
void esp_report2(void) {
    char json[256];
    snprintf(json, sizeof(json),
        "{\\\"services\\\":[{\\\"service_id\\\":\\\"BasicData\\\"\\,"
        "\\\"properties\\\":{\\\"longitude\\\":%.6f\\,\\\"latitude\\\":%.6f\\,"
        "\\\"temperature\\\":%d\\,\\\"humidity\\\":%d}}]}",
        longitude_decimal, latitude_decimal, (int)aht20_data.temperature, (int)aht20_data.humidity);

    my_printf(&huart3, "AT+MQTTPUB=0,\"%s\",\"%s\",0,0\r\n", MQTT_TOPIC, json);
}

// printfé‡å®šå‘åˆ°UART3
int my_printf(UART_HandleTypeDef *huart, const char *format, ...) {
    char buffer[512];
    va_list args;
    va_start(args, format);
    int len = vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    HAL_UART_Transmit(huart, (uint8_t*)buffer, len, 0xFF);
    return len;
}
```

**å…³é”®æ³¨æ„äº‹é¡¹**
- ESP01Så¿…é¡»ä½¿ç”¨**å¤–éƒ¨3.3Vç¨³å‹æ¨¡å—**ä¾›ç”µï¼ˆä¸èƒ½ç›´æ¥ç”¨STM32çš„3.3Vï¼‰
- ATæŒ‡ä»¤ä¸­çš„JSONéœ€è¦ç”¨ `\\\"` è½¬ä¹‰åŒå¼•å·
- åˆ†æ‰¹ä¸Šä¼ æ•°æ®ï¼Œé¿å…å•æ¡JSONè¿‡é•¿ï¼ˆ>256å­—èŠ‚ï¼‰

---

### é˜¶æ®µäº”ï¼šä»»åŠ¡è°ƒåº¦å™¨é›†æˆï¼ˆDay 13ï¼‰

**è°ƒåº¦å™¨å®ç°** (scheduler.c)
```c
typedef struct {
    void (*task_func)(void);  // ä»»åŠ¡å‡½æ•°æŒ‡é’ˆ
    uint32_t period_ms;       // æ‰§è¡Œå‘¨æœŸï¼ˆmsï¼‰
    uint32_t last_run;        // ä¸Šæ¬¡è¿è¡Œæ—¶é—´ï¼ˆmsï¼‰
} task_t;

// ä»»åŠ¡åˆ—è¡¨
static task_t scheduler_task[] = {
    {aht20_task,        100,  0},   // AHT20æ¸©æ¹¿åº¦
    {icm20608_task,     100,  0},   // ICM20608å§¿æ€
    {mq2_task,          100,  0},   // MQ2çƒŸé›¾
    {max30102_task,     200,  0},   // MAX30102å¿ƒç‡è¡€æ°§
    {atgm336h_task,     100,  0},   // GPSå®šä½
    {send_flag_to_asr,  1000, 0},   // å‘è¯­éŸ³å‘é€æ ‡å¿—
    {process_asr_data,  20,   0},   // å¤„ç†è¯­éŸ³æ•°æ®
    {esp_report1,       350,  0},   // ä¸ŠæŠ¥ä¼ æ„Ÿå™¨æ•°æ®
    {esp_report2,       1000, 0},   // ä¸ŠæŠ¥ç¯å¢ƒæ•°æ®
};

uint8_t task_num;

void scheduler_init(void) {
    task_num = sizeof(scheduler_task) / sizeof(task_t);
}

void scheduler_run(void) {
    for(uint8_t i = 0; i < task_num; i++) {
        uint32_t now = HAL_GetTick();

        // åˆ¤æ–­æ˜¯å¦åˆ°è¾¾æ‰§è¡Œæ—¶åˆ»
        if(now - scheduler_task[i].last_run >= scheduler_task[i].period_ms) {
            scheduler_task[i].last_run = now;
            scheduler_task[i].task_func();  // æ‰§è¡Œä»»åŠ¡
        }
    }
}
```

**main.cé›†æˆ**
```c
#include "scheduler.h"

int main(void) {
    // ç³»ç»Ÿåˆå§‹åŒ–
    HAL_Init();
    SystemClock_Config();

    // å¤–è®¾åˆå§‹åŒ–
    MX_GPIO_Init();
    MX_ADC1_Init();
    MX_I2C1_Init();
    MX_USART1_UART_Init();
    MX_USART2_UART_Init();
    MX_USART3_UART_Init();
    MX_TIM1_Init();

    // ä¼ æ„Ÿå™¨åˆå§‹åŒ–
    AHT20_Init();
    ICM20608_Init();
    MAX30102_Init();
    ESP01S_Init();

    // è°ƒåº¦å™¨åˆå§‹åŒ–
    scheduler_init();

    // å¯åŠ¨ADC DMA
    HAL_ADC_Start_DMA(&hadc1, adc_buffer, 30);

    // å¯åŠ¨UART2ä¸­æ–­æ¥æ”¶ï¼ˆGPSï¼‰
    HAL_UART_Receive_IT(&huart2, &uart2_rx_byte, 1);

    while(1) {
        scheduler_run();  // è¿è¡Œè°ƒåº¦å™¨
    }
}
```

---

## âœ… æµ‹è¯•ä¸è°ƒè¯•

### å•å…ƒæµ‹è¯•æ¸…å•

| æ¨¡å— | æµ‹è¯•é¡¹ | æœŸæœ›ç»“æœ | æµ‹è¯•æ–¹æ³• |
|-----|-------|---------|---------|
| AHT20 | è¯»å–æ¸©æ¹¿åº¦ | æ­£å¸¸èŒƒå›´å€¼ | ä¸²å£æ‰“å° |
| ICM20608 | è¯»å–å§¿æ€è§’ | pitch/rollåœ¨Â±90Â° | ä¸²å£æ‰“å° |
| MQ2 | è¯»å–ppm | æ¸…æ´ç¯å¢ƒ<100ppm | ä¸²å£æ‰“å° |
| MAX30102 | è¯»å–å¿ƒç‡è¡€æ°§ | HR:60-100, SpO2>95 | ä¸²å£æ‰“å° |
| GPS | è§£æåæ ‡ | åè¿›åˆ¶åº¦æ•°æ ¼å¼ | ä¸²å£æ‰“å° |
| è¯­éŸ³ | è¯†åˆ«æ§åˆ¶ | ç»§ç”µå™¨åŠ¨ä½œ | è§‚å¯ŸLED |
| WiFi | MQTTè¿æ¥ | åä¸ºäº‘æ˜¾ç¤ºåœ¨çº¿ | äº‘ç«¯æŸ¥çœ‹ |
| ä¸Šäº‘ | æ•°æ®ä¸ŠæŠ¥ | äº‘ç«¯å®æ—¶æ›´æ–° | äº‘ç«¯æŸ¥çœ‹ |

### å¸¸è§é—®é¢˜æ’æŸ¥

**é—®é¢˜1: AHT20åˆå§‹åŒ–å¤±è´¥**
- æ£€æŸ¥I2Cåœ°å€æ˜¯å¦æ­£ç¡®ï¼ˆ0x70ï¼‰
- æ£€æŸ¥ä¸Šç”µå»¶æ—¶æ˜¯å¦>=40ms
- ç”¨é€»è¾‘åˆ†æä»ªæŸ¥çœ‹I2Cæ³¢å½¢

**é—®é¢˜2: ICM20608æ•°æ®å…¨ä¸º0**
- æ£€æŸ¥I2Cåœ°å€ï¼ˆ0xD0æˆ–0xD2ï¼Œå–å†³äºAD0å¼•è„šï¼‰
- æ£€æŸ¥æ˜¯å¦æ‰§è¡Œäº†å¤ä½å‘½ä»¤
- æ£€æŸ¥å¯„å­˜å™¨è¯»å†™æ˜¯å¦æˆåŠŸ

**é—®é¢˜3: MQ2æ•°æ®ä¸ç¨³å®š**
- æ£€æŸ¥æ˜¯å¦é¢„çƒ­è¶³å¤Ÿæ—¶é—´ï¼ˆ1-2åˆ†é’Ÿï¼‰
- æ£€æŸ¥ä¾›ç”µæ˜¯å¦ç¨³å®šï¼ˆ5Vï¼‰
- æ£€æŸ¥æ˜¯å¦å…±åœ°

**é—®é¢˜4: MAX30102æ— æ•°æ®**
- æ£€æŸ¥è½¯ä»¶I2Cæ—¶åºæ˜¯å¦æ­£ç¡®
- æ£€æŸ¥æ‰‹æŒ‡æ˜¯å¦ç´§è´´ä¼ æ„Ÿå™¨
- æ£€æŸ¥LEDç”µæµæ˜¯å¦è¶³å¤Ÿï¼ˆé»˜è®¤7mAï¼‰

**é—®é¢˜5: GPSæ— æ³•å®šä½**
- ç¡®ä¿åœ¨å®¤å¤–ç©ºæ—·ç¯å¢ƒ
- å†·å¯åŠ¨éœ€ç­‰å¾…1-3åˆ†é’Ÿ
- æ£€æŸ¥æ³¢ç‰¹ç‡æ˜¯å¦ä¸º9600

**é—®é¢˜6: ESP01Sè¿æ¥å¤±è´¥**
- æ£€æŸ¥WiFiåç§°å’Œå¯†ç æ˜¯å¦æ­£ç¡®
- æ£€æŸ¥ä¾›ç”µæ˜¯å¦ç¨³å®šï¼ˆ3.3Vï¼Œç”µæµ>200mAï¼‰
- æ£€æŸ¥MQTTå‚æ•°æ˜¯å¦æ­£ç¡®
- ç”¨ä¸²å£åŠ©æ‰‹æ‰‹åŠ¨æµ‹è¯•ATæŒ‡ä»¤

---

## ğŸ¯ é¢è¯•è®²è§£è¦ç‚¹

### é¡¹ç›®ä»‹ç»è¯æœ¯ï¼ˆ1åˆ†é’Ÿç‰ˆæœ¬ï¼‰
"è¿™æ˜¯ä¸€ä¸ªåŸºäºSTM32F407çš„**å·¥ä¸šçº§æ™ºèƒ½å®‰å…¨å¸½ç›‘æµ‹ç³»ç»Ÿ**,ä¸»è¦åº”ç”¨äºå·¥åœ°ã€çŸ¿äº•ç­‰å±é™©ä½œä¸šç¯å¢ƒã€‚

ç³»ç»Ÿé›†æˆäº†**6ç§ä¼ æ„Ÿå™¨**:æ¸©æ¹¿åº¦ï¼ˆAHT20ï¼‰ã€å§¿æ€ï¼ˆICM-20608-Gï¼‰ã€çƒŸé›¾ï¼ˆMQ2ï¼‰ã€å¿ƒç‡è¡€æ°§ï¼ˆMAX30102ï¼‰ã€GPSå®šä½ï¼ˆATGM336Hï¼‰ï¼Œé€šè¿‡**WiFiæ¨¡å—**å®æ—¶ä¸Šä¼ æ•°æ®åˆ°**åä¸ºäº‘IoTå¹³å°**ã€‚

é‡‡ç”¨**è½»é‡çº§ä»»åŠ¡è°ƒåº¦å™¨**å®ç°9ä¸ªä»»åŠ¡çš„å¹¶è¡Œæ‰§è¡Œï¼Œæ— éœ€RTOSã€‚é€šè¿‡**ç¦»çº¿è¯­éŸ³æ¨¡å—**å®ç°è¯­éŸ³æ§åˆ¶å’ŒæŠ¥è­¦æ’­æŠ¥ã€‚

é¡¹ç›®çš„æŠ€æœ¯éš¾ç‚¹åŒ…æ‹¬ï¼š
1. MAX30102å¿ƒç‡è¡€æ°§çš„**å¤šçº§æ»¤æ³¢ç®—æ³•**ï¼Œå°†è¯¯å·®ä»Â±15bpmé™åˆ°Â±5bpm
2. GPSçš„**NMEAåè®®è§£æ**å’Œåæ ‡è½¬æ¢
3. **MQTTé•¿è¿æ¥ç»´æŠ¤**ï¼Œä¿è¯æ•°æ®ä¸Šä¼ å¯é æ€§

æ•´ä¸ªç³»ç»Ÿä»£ç çº¦**3500è¡Œ**ï¼Œå¼€å‘å‘¨æœŸ**2-3å‘¨**ï¼Œå·²å®Œæ•´æµ‹è¯•éªŒè¯ã€‚"

### æ ¸å¿ƒæŠ€æœ¯ç‚¹æ€»ç»“

| æŠ€æœ¯ç‚¹ | å®ç°ç»†èŠ‚ | é¢è¯•è¯æœ¯ |
|-------|---------|---------|
| å¤šä¼ æ„Ÿå™¨è°ƒåº¦ | æ—¶é—´ç‰‡è½®è½¬è°ƒåº¦å™¨ | "è®¾è®¡äº†è½»é‡çº§è°ƒåº¦å™¨ï¼Œæ¯”RTOSèŠ‚çœ2KB RAM" |
| å¿ƒç‡è¡€æ°§æ»¤æ³¢ | æ»‘åŠ¨å¹³å‡+ä½é€šæ»¤æ³¢ | "å¤šçº§æ»¤æ³¢å°†æµ‹é‡è¯¯å·®é™ä½67%" |
| GPSæ•°æ®è§£æ | NMEA-0183åè®® | "å®ç°äº†å®¹é”™è§£æå™¨ï¼Œå…¼å®¹å¤šç§GPSæ¨¡å—" |
| MQTTä¸Šäº‘ | æ–­çº¿é‡è¿æœºåˆ¶ | "å®ç°äº†å¿ƒè·³æ£€æµ‹ï¼Œä¿è¯99.5%åœ¨çº¿ç‡" |
| å§¿æ€è§£ç®— | äº’è¡¥æ»¤æ³¢ç®—æ³• | "èåˆåŠ é€Ÿåº¦è®¡å’Œé™€èºä»ªï¼Œé¿å…ä¸‡å‘é”" |
| è½¯ä»¶I2C | GPIOæ¨¡æ‹Ÿæ—¶åº | "å®ç°äº†ç²¾ç¡®åˆ°usçš„I2Cæ—¶åºæ§åˆ¶" |

### å¯èƒ½çš„è¿½é—®åŠå›ç­”

**Q: ä¸ºä»€ä¹ˆç”¨è°ƒåº¦å™¨è€Œä¸ç”¨RTOSï¼Ÿ**
A: "è€ƒè™‘åˆ°STM32F407èµ„æºå……è¶³ä½†ä¸éœ€è¦å¤æ‚ä»»åŠ¡ç®¡ç†ï¼Œè‡ªå·±å®ç°çš„è½»é‡çº§è°ƒåº¦å™¨æ›´çµæ´»ï¼Œä»…å ç”¨ä¸åˆ°100å­—èŠ‚RAMï¼Œä¸”æ²¡æœ‰RTOSçš„å­¦ä¹ æˆæœ¬å’Œç§»æ¤æˆæœ¬ã€‚å¦‚æœæœªæ¥ä»»åŠ¡å¢å¤šï¼Œå¯ä»¥å¹³æ»‘å‡çº§åˆ°FreeRTOSã€‚"

**Q: å¦‚ä½•ä¿è¯æ•°æ®ä¸Šäº‘çš„å®æ—¶æ€§ï¼Ÿ**
A: "é‡‡ç”¨äº†åˆ†æ‰¹ä¸Šä¼ ç­–ç•¥ï¼šä¼ æ„Ÿå™¨æ•°æ®350msä¸Šä¼ ä¸€æ¬¡ï¼Œç¯å¢ƒæ•°æ®1000msä¸Šä¼ ä¸€æ¬¡ã€‚åŒæ—¶å®ç°äº†æ–­çº¿é‡è¿æœºåˆ¶ï¼Œç½‘ç»œæ³¢åŠ¨æ—¶è‡ªåŠ¨é‡è¿ï¼Œä¿è¯äº†æ•°æ®ä¸ä¸¢å¤±ã€‚å®æµ‹åœ¨WiFiç¨³å®šç¯å¢ƒä¸‹ï¼Œæ•°æ®å»¶è¿Ÿ<500msã€‚"

**Q: MAX30102çš„æ»¤æ³¢ç®—æ³•åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ**
A: "é‡‡ç”¨äº†ä¸¤çº§æ»¤æ³¢ï¼šé¦–å…ˆç”¨20ä¸ªæ ·æœ¬çš„æ»‘åŠ¨çª—å£åšå¹³å‡ï¼Œé™ä½éšæœºå™ªå£°ï¼›ç„¶åç”¨Î±=0.05çš„ä½é€šæ»¤æ³¢å™¨ï¼ŒæŠ‘åˆ¶é«˜é¢‘å¹²æ‰°ã€‚è¿™ç§ç»„åˆæ—¢ä¿ç•™äº†å¿ƒè·³çš„åŠ¨æ€ç‰¹æ€§ï¼Œåˆå»é™¤äº†æ‰‹æŒ‡æŠ–åŠ¨ç­‰å™ªå£°ã€‚"

**Q: å¦‚ä½•å¤„ç†I2Cæ€»çº¿å†²çªï¼Ÿ**
A: "AHT20å’ŒICM20608å…±äº«I2C1æ€»çº¿ï¼Œé€šè¿‡ä¸åŒçš„I2Cåœ°å€ï¼ˆ0x70å’Œ0xD0ï¼‰åŒºåˆ†ã€‚åœ¨è°ƒåº¦å™¨ä¸­ï¼Œä¸¤ä¸ªä»»åŠ¡çš„æ‰§è¡Œæ—¶é—´é”™å¼€ï¼ˆéƒ½æ˜¯100mså‘¨æœŸä½†èµ·å§‹æ—¶é—´ä¸åŒï¼‰ï¼Œé¿å…äº†åŒæ—¶è®¿é—®æ€»çº¿ã€‚"

**Q: é¡¹ç›®é‡åˆ°çš„æœ€å¤§å›°éš¾æ˜¯ä»€ä¹ˆï¼Ÿ**
A: "æœ€å¤§å›°éš¾æ˜¯MAX30102çš„æ•°æ®å™ªå£°é—®é¢˜ã€‚æœ€å¼€å§‹ç›´æ¥ç”¨å®˜æ–¹ç®—æ³•ï¼Œå¿ƒç‡å€¼è·³å˜éå¸¸å¤§ï¼ˆÂ±20bpmï¼‰ã€‚åæ¥ç ”ç©¶äº†PPGä¿¡å·ç‰¹ç‚¹ï¼Œå‘ç°éœ€è¦å¤šçº§æ»¤æ³¢ã€‚ç»è¿‡å¤§é‡å®éªŒï¼Œæ‰¾åˆ°äº†æœ€ä¼˜å‚æ•°ç»„åˆï¼Œæœ€ç»ˆå°†è¯¯å·®é™åˆ°Â±5bpmã€‚"

---

## ğŸ“¦ äº¤ä»˜æ¸…å•

å®Œæˆé¡¹ç›®åï¼Œåº”å‡†å¤‡ä»¥ä¸‹ææ–™ï¼š

### ä»£ç ä»“åº“
- GitHub/Giteeä»“åº“é“¾æ¥
- å®Œæ•´çš„Keilå·¥ç¨‹
- CubeMXé…ç½®æ–‡ä»¶(.ioc)
- æ‰€æœ‰æºä»£ç å’Œå¤´æ–‡ä»¶

### æ–‡æ¡£
- âœ… æœ¬å¼€å‘æµç¨‹æ–‡æ¡£
- âœ… ç¡¬ä»¶è¿æ¥æ–‡æ¡£
- âœ… ç”¨æˆ·ä½¿ç”¨æ‰‹å†Œ
- âœ… é¢è¯•é—®ç­”å®å…¸
- âœ… æŠ€æœ¯å®ç°è¯¦è§£
- âœ… README.md

### æ¼”ç¤ºææ–™
- é¡¹ç›®æ¼”ç¤ºè§†é¢‘ï¼ˆ3-5åˆ†é’Ÿï¼‰
- PPTæ¼”ç¤ºæ–‡ç¨¿
- æµ‹è¯•æ•°æ®æˆªå›¾
- åä¸ºäº‘å¹³å°æˆªå›¾

### ç¡¬ä»¶å®ç‰©
- å®Œæ•´ç»„è£…çš„ç¡¬ä»¶ç³»ç»Ÿ
- å¤‡ç”¨ä¼ æ„Ÿå™¨æ¨¡å—
- è¿æ¥çº¿ææ•´ç†å¥½

---

## ğŸ“ åç»­æ‰©å±•æ–¹å‘

1. **ç¡¬ä»¶å‡çº§**
   - å¢åŠ OLEDæ˜¾ç¤ºå±å®æ—¶æ˜¾ç¤ºæ•°æ®
   - å¢åŠ èœ‚é¸£å™¨æŠ¥è­¦
   - å¢åŠ SDå¡å­˜å‚¨å†å²æ•°æ®
   - å¢åŠ ç”µæ± ç”µé‡æ£€æµ‹

2. **è½¯ä»¶ä¼˜åŒ–**
   - ç§»æ¤FreeRTOSå®ç°æŠ¢å å¼è°ƒåº¦
   - å¢åŠ Bootloaderæ”¯æŒOTAå‡çº§
   - å¢åŠ ä½åŠŸè€—æ¨¡å¼å»¶é•¿ç»­èˆª
   - å¢åŠ æ•°æ®åŠ å¯†ä¼ è¾“

3. **ç®—æ³•æ”¹è¿›**
   - ä½¿ç”¨å¡å°”æ›¼æ»¤æ³¢æå‡å§¿æ€ç²¾åº¦
   - å¢åŠ è®¡æ­¥å™¨åŠŸèƒ½
   - å¢åŠ è·Œå€’æ£€æµ‹ç®—æ³•ï¼ˆç»“åˆåŠ é€Ÿåº¦å’Œè§’åº¦ï¼‰
   - å¢åŠ å¼‚å¸¸æ•°æ®è‡ªåŠ¨æ ¡å‡†

4. **äº‘ç«¯åŠŸèƒ½**
   - å¼€å‘å¾®ä¿¡å°ç¨‹åºå®æ—¶ç›‘æ§
   - å¢åŠ å†å²æ•°æ®å¯è§†åŒ–
   - å¢åŠ å¼‚å¸¸æŠ¥è­¦æ¨é€
   - å¢åŠ å¤šè®¾å¤‡ç®¡ç†

---

## ğŸ“ æŠ€æœ¯æ”¯æŒ

**é‡åˆ°é—®é¢˜æ—¶çš„è§£å†³è·¯å¾„ï¼š**
1. æŸ¥çœ‹æœ¬æ–‡æ¡£çš„"æµ‹è¯•ä¸è°ƒè¯•"ç« èŠ‚
2. æŸ¥çœ‹åŸç†å›¾å’Œæ•°æ®æ‰‹å†Œ
3. ä½¿ç”¨ä¸²å£è°ƒè¯•åŠ©æ‰‹æŸ¥çœ‹è¾“å‡º
4. ä½¿ç”¨é€»è¾‘åˆ†æä»ªåˆ†ææ³¢å½¢
5. åœ¨GitHub Issuesæé—®
6. æœç´¢ç›¸å…³æŠ€æœ¯è®ºå›ï¼ˆCSDNã€STM32ç¤¾åŒºï¼‰

**æ¨èå­¦ä¹ èµ„æºï¼š**
- STM32ä¸­æ–‡ç¤¾åŒº: https://www.stmcu.org.cn
- æ­£ç‚¹åŸå­æ•™ç¨‹: é€‚åˆå…¥é—¨
- é‡ç«æ•™ç¨‹: æ·±å…¥HALåº“
- Bilibiliæœç´¢"STM32é¡¹ç›®å®æˆ˜"

---

**ç¥ä½ å¤åˆ»æˆåŠŸï¼Œé¢è¯•é¡ºåˆ©ï¼** ğŸ‰
